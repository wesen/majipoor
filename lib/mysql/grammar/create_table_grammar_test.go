package grammar

import (
	"github.com/stretchr/testify/assert"
	require "github.com/stretchr/testify/require"
	"testing"
)

func TestParseCaseInsensitive(t *testing.T) {
	for _, s := range []string{
		"CREATE TABLE foobar ( id INT )",
		"create table foobar ( id INT )",
	} {
		ast, err := Parse(s)
		if assert.Nil(t, err) && assert.NotNil(t, ast) {
			assert.Equal(t, ast.Name, "foobar")
		}
	}
}

func TestParseCaseComment(t *testing.T) {
	for _, s := range []string{
		"CREATE TABLE foobar ( id INT ) /* generated by server */",
	} {
		ast, err := Parse(s)
		if assert.Nil(t, err) && assert.NotNil(t, ast) {
			assert.Equal(t, "foobar", ast.Name)
		}
	}
}

func TestTableName(t *testing.T) {
	ast, err := Parse("CREATE TABLE foobar ( id INT )")
	require.Nil(t, err)
	assert.Equal(t, "foobar", ast.Name)

	ast, err = Parse("CREATE TABLE foobar.baz ( id INT )")
	require.Nil(t, err)
	assert.Equal(t, "foobar.baz", ast.Name)
}

func TestParseBit(t *testing.T) {
	ast, err := Parse("CREATE TABLE foobar ( bitColumn BIT )")
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		assert.Equal(t, "bitColumn", definition.ColumnName)
		require.NotNil(t, definition.DataType.Bit)
		require.Nil(t, definition.DataType.Bit.Precision)
		require.Nil(t, definition.DataType.Integer)
	}
	ast, err = Parse("CREATE TABLE foobar ( bitColumn BIT(5) )")
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		assert.Equal(t, "bitColumn", definition.ColumnName)
		require.NotNil(t, definition.DataType.Bit)
		require.Equal(t, 5, *definition.DataType.Bit.Precision)
		require.Nil(t, definition.DataType.Integer)
	}
	ast, err = Parse("CREATE TABLE foobar ( bitColumn BIT (5 ) )")
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		assert.Equal(t, "bitColumn", definition.ColumnName)
		require.NotNil(t, definition.DataType.Bit)
		require.Equal(t, 5, *definition.DataType.Bit.Precision)
		require.Nil(t, definition.DataType.Integer)
	}
}

func TestParseInteger(t *testing.T) {
	for _, s := range []string{
		"CREATE TABLE foobar ( intColumn TINYINT )",
		"CREATE TABLE foobar ( intColumn tinyint )",
	} {
		ast, err := Parse(s)
		if assert.Nil(t, err) && assert.NotNil(t, ast) {
			definition := ast.CreateDefinition[0].ColumnDefinition.Simple
			assert.Equal(t, "intColumn", definition.ColumnName)
			require.NotNil(t, definition.DataType.Integer)
			require.Nil(t, definition.DataType.Integer.Precision)
			require.NotNil(t, definition.DataType.Integer.Type)
			require.Equal(t, UppercaseString("TINYINT"), *definition.DataType.Integer.Type)
			require.Equal(t, false, definition.DataType.Integer.Unsigned)
			require.Nil(t, definition.DataType.Bit)
		}
	}

	ast, err := Parse("CREATE TABLE foobar ( intColumn TINYINT(4) UNSIGNED ZEROFILL )")
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		integer := ast.CreateDefinition[0].ColumnDefinition.Simple.DataType.Integer
		require.Equal(t, UppercaseString("TINYINT"), *integer.Type)
		require.True(t, integer.Unsigned)
		require.True(t, integer.Zerofill)
	}
}

func TestParseBool(t *testing.T) {
	for _, s := range []string{
		"CREATE TABLE foobar ( boolColumn BOOL )",
		"CREATE TABLE foobar ( boolColumn boolEAN )",
		"CREATE TABLE foobar ( boolColumn BOOLEAN )",
	} {
		ast, err := Parse(s)
		if assert.Nil(t, err) && assert.NotNil(t, ast) {
			require.NotNil(t, ast.CreateDefinition[0].ColumnDefinition)
			require.NotNil(t, ast.CreateDefinition[0].ColumnDefinition.Simple)
			definition := ast.CreateDefinition[0].ColumnDefinition.Simple
			assert.Equal(t, "boolColumn", definition.ColumnName)
			require.True(t, definition.DataType.Bool)
		}
	}
}

func TestParseMultipleColumns(t *testing.T) {
	ast, err := Parse(`CREATE TABLE foobar ( 
	bitColumn BIT(5) , 
    foobar VARCHAR(30) NOT NULL DEFAULT 'foo' ,
     blop INT DEFAULT 2
    )
`)
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		require.Equal(t, 3, len(ast.CreateDefinition))
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.False(t, definition.NotNull)
		require.Equal(t, "bitColumn", definition.ColumnName)
		require.Nil(t, definition.Default)
		require.NotNil(t, definition.DataType.Bit)

		definition = ast.CreateDefinition[1].ColumnDefinition.Simple
		require.True(t, definition.NotNull)
		require.Equal(t, "foobar", definition.ColumnName)
		require.NotNil(t, definition.Default)
		require.Equal(t, "foo", *definition.Default.String)

		definition = ast.CreateDefinition[2].ColumnDefinition.Simple
		require.False(t, definition.NotNull)
		require.Equal(t, "blop", definition.ColumnName)
		require.NotNil(t, definition.Default)
		require.Equal(t, 2.0, *definition.Default.Number)
		require.NotNil(t, definition.DataType.Integer)
		require.Equal(t, UppercaseString("INT"), *definition.DataType.Integer.Type)
	}
}

func TestParseEnum(t *testing.T) {
	ast, err := Parse(`CREATE TABLE foobar ( enumColumn ENUM('foo', 'bar') DEFAULT 'foo' )`)

	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.False(t, definition.NotNull)
		require.NotNil(t, definition.Default)
		require.NotNil(t, definition.DataType.EnumSet)
		require.False(t, definition.DataType.EnumSet.IsSet)
		require.Equal(t, "foo", *definition.Default.String)

		require.EqualValues(t, []string{"foo", "bar"}, definition.DataType.EnumSet.Values)
	}

	ast, err = Parse(`CREATE TABLE foobar ( setColumn SET('foo', 'bar') CHARACTER SET utf8mb4)`)
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.False(t, definition.NotNull)
		require.Nil(t, definition.Default)
		require.NotNil(t, definition.DataType.EnumSet)
		require.True(t, definition.DataType.EnumSet.IsSet)
		require.EqualValues(t, []string{"foo", "bar"}, definition.DataType.EnumSet.Values)
		require.Equal(t, "utf8mb4", *definition.DataType.EnumSet.CharacterSet)
	}

	ast, err = Parse(`CREATE TABLE foobar ( setColumn SET('foo', 'bar', 'baz') CHARACTER SET utf8mb4 DEFAULT 'foo,bar')`)
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.False(t, definition.NotNull)
		require.NotNil(t, definition.Default)
		require.NotNil(t, definition.DataType.EnumSet)
		require.True(t, definition.DataType.EnumSet.IsSet)
		require.EqualValues(t, []string{"foo", "bar", "baz"}, definition.DataType.EnumSet.Values)
		require.Equal(t, "utf8mb4", *definition.DataType.EnumSet.CharacterSet)
		require.Equal(t, "foo,bar", *definition.Default.String)
	}
}

func TestParseColumnOptions(t *testing.T) {
	ast, err := Parse("CREATE TABLE foobar ( bitColumn BIT(5) NOT NULL DEFAULT 1 VISIBLE AUTO_INCREMENT UNIQUE KEY PRIMARY KEY COMMENT 'comment')")
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.True(t, definition.NotNull)
		require.NotNil(t, definition.Default)
		require.True(t, definition.Visible)
		require.True(t, definition.AutoIncrement)
		require.True(t, definition.UniqueKey)
		require.True(t, definition.PrimaryKey)
		require.Equal(t, *definition.Comment, "comment")
	}

	ast, err = Parse(`CREATE TABLE foobar ( 
	bitColumn BIT(5) 
      NOT NULL
      DEFAULT 1
      INVISIBLE
      AUTO_INCREMENT UNIQUE KEY
      PRIMARY KEY
      COMMENT 'comment and comment'
      COLLATE utf8_bin
      COLUMN_FORMAT DEfaULT
    )
`)
	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.True(t, definition.NotNull)
		require.NotNil(t, definition.Default)
		require.False(t, definition.Visible)
		require.True(t, definition.AutoIncrement)
		require.True(t, definition.UniqueKey)
		require.True(t, definition.PrimaryKey)
		require.Equal(t, *definition.Comment, "comment and comment")
		require.Equal(t, *definition.Collate, "utf8_bin")
		require.Equal(t, *definition.ColumnFormat, UppercaseString("DEFAULT"))
	}
	ast, err = Parse(`CREATE TABLE foobar ( 
	bitColumn BIT(5) 
      COLUMN_FORMAT blabl
    )
`)
	assert.NotNil(t, err)
}

func TestParseColumnReference(t *testing.T) {
	ast, err := Parse(`CREATE TABLE foobar ( 
          id INT REFERENCES foobar(id) MATCH FULL 
          ON DELETE CASCADE 
          ON UPDATE SET NULL,
          name TEXT REFERENCES foobar(name(23) DESC, id ASC) MATCH PARTIAL 
          ON UPDATE NO ACTION
)`)

	if assert.Nil(t, err) && assert.NotNil(t, ast) {
		definition := ast.CreateDefinition[0].ColumnDefinition.Simple
		require.NotNil(t, definition.ReferenceDefinition)
		require.Equal(t, "foobar", definition.ReferenceDefinition.TableName)
		require.Equal(t, 1, len(definition.ReferenceDefinition.Keys))
		require.Equal(t, "id", definition.ReferenceDefinition.Keys[0].KeyPartColumn.Name)
		require.False(t, definition.ReferenceDefinition.Keys[0].IsAsc)
		require.Equal(t, "FULL", *definition.ReferenceDefinition.Match)
		require.Equal(t, ReferenceOption("CASCADE"), *definition.ReferenceDefinition.OnDelete)
		require.Equal(t, ReferenceOption("SET NULL"), *definition.ReferenceDefinition.OnUpdate)

		definition = ast.CreateDefinition[1].ColumnDefinition.Simple
		require.NotNil(t, definition.ReferenceDefinition)
		require.Equal(t, "foobar", definition.ReferenceDefinition.TableName)
		require.Equal(t, 2, len(definition.ReferenceDefinition.Keys))
		require.Equal(t, "name", definition.ReferenceDefinition.Keys[0].KeyPartColumn.Name)
		require.Equal(t, 23, *definition.ReferenceDefinition.Keys[0].KeyPartColumn.Length)
		require.Equal(t, "id", definition.ReferenceDefinition.Keys[1].KeyPartColumn.Name)
		require.False(t, definition.ReferenceDefinition.Keys[0].IsAsc)
		require.True(t, definition.ReferenceDefinition.Keys[1].IsAsc)

		require.Equal(t, "PARTIAL", *definition.ReferenceDefinition.Match)
		require.Nil(t, definition.ReferenceDefinition.OnDelete)
		require.Equal(t, ReferenceOption("NO ACTION"), *definition.ReferenceDefinition.OnUpdate)
	}
}

func TestParseTableOptions(t *testing.T) {
	for _, s := range []string{
		`CREATE TABLE foobar ( id INT ) 
     AUTOEXTEND_SIZE = 23
     AUTO_INCREMENT = 2
     AVG_ROW_LENGTH = 3
`,
		`CREATE TABLE foobar ( id INT ) 
     AUTOEXTEND_SIZE 23
     AUTO_INCREMENT 2
     AVG_ROW_LENGTH 3
`,
	} {
		ast, err := Parse(s)

		if assert.Nil(t, err) && assert.NotNil(t, ast) {
			require.Equal(t, 3, len(ast.TableOptions))
			option := ast.TableOptions[0]
			require.NotNil(t, option.AutoExtendSize)
			require.Equal(t, 23, *option.AutoExtendSize)

			option = ast.TableOptions[1]
			require.NotNil(t, option.AutoIncrement)
			require.Equal(t, 2, *option.AutoIncrement)

			option = ast.TableOptions[2]
			require.NotNil(t, option.AvgRowLength)
			require.Equal(t, 3, *option.AvgRowLength)
		}
	}

	for _, s := range []string{
		`CREATE TABLE foobar ( id INT ) DEFAULT CHARACTER SET utf8mb4`,
		`CREATE TABLE foobar ( id INT ) CHARACTER SET = utf8mb4`,
	} {
		ast, err := Parse(s)
		require.Nil(t, err)
		require.Equal(t, 1, len(ast.TableOptions))
		require.NotNil(t, ast.TableOptions[0].CharacterSet)
		require.Equal(t, "utf8mb4", *ast.TableOptions[0].CharacterSet)
	}

	for _, s := range []string{
		`CREATE TABLE foobar ( id INT ) CHECKSUM = 1 DEFAULT COLLATE foobar`,
		`CREATE TABLE foobar ( id INT ) CHECKSUM 1 COLLATE foobar`,
	} {
		ast, err := Parse(s)
		require.Nil(t, err)
		require.Equal(t, 2, len(ast.TableOptions))
		require.NotNil(t, ast.TableOptions[0].Checksum)
		require.Equal(t, 1, *ast.TableOptions[0].Checksum)
		require.NotNil(t, ast.TableOptions[1].Collation)
		require.Equal(t, "foobar", *ast.TableOptions[1].Collation)
	}

	for _, s := range []string{
		`CREATE TABLE foobar (id INT) 
  COMMENT = 'string'
  COMPRESSION = 'ZLIB'
  CONNECTION = 'connect_string'
  DATA DIRECTORY = 'absolute path to directory'
  DELAY_KEY_WRITE = 1
  ENCRYPTION = 'Y'
  ENGINE = InnoDB`,
		`CREATE TABLE foobar (id INT) 
  COMMENT 'string'
  COMPRESSION 'ZLIB'
  CONNECTION 'connect_string'
  DATA DIRECTORY 'absolute path to directory'
  DELAY_KEY_WRITE 1
  ENCRYPTION 'Y'
  ENGINE InnoDB`,
	} {
		ast, err := Parse(s)
		require.Nil(t, err)
		require.Equal(t, 7, len(ast.TableOptions))
		require.NotNil(t, ast.TableOptions[0].Comment)
		require.Equal(t, "string", *ast.TableOptions[0].Comment)
		require.NotNil(t, ast.TableOptions[1].Compression)
		require.Equal(t, "ZLIB", *ast.TableOptions[1].Compression)
		require.NotNil(t, ast.TableOptions[2].Connection)
		require.Equal(t, "connect_string", *ast.TableOptions[2].Connection)
		require.NotNil(t, ast.TableOptions[3].DataDirectory)
		require.Equal(t, "absolute path to directory", *ast.TableOptions[3].DataDirectory)
		require.NotNil(t, ast.TableOptions[4].DelayKeyWrite)
		require.Equal(t, 1, *ast.TableOptions[4].DelayKeyWrite)
		require.NotNil(t, ast.TableOptions[5].Encryption)
		require.Equal(t, "Y", *ast.TableOptions[5].Encryption)
		require.NotNil(t, ast.TableOptions[6].Engine)
		require.Equal(t, "InnoDB", *ast.TableOptions[6].Engine)
	}

	for _, s := range []string{
		`CREATE TABLE foobar (id INT) 
  INDEX DIRECTORY = 'absolute path to directory'
  ENGINE_ATTRIBUTE = 'foobar'
  INSERT_METHOD = NO
  KEY_BLOCK_SIZE = 23
  MAX_ROWS = 12
  MIN_ROWS = 1
  PACK_KEYS = DEFAULT
`,
		`CREATE TABLE foobar (id INT) 
  INDEX DIRECTORY 'absolute path to directory'
  ENGINE_ATTRIBUTE 'foobar'
  INSERT_METHOD NO
  KEY_BLOCK_SIZE 23
  MAX_ROWS 12
  MIN_ROWS 1
  PACK_KEYS DEFAULT`,
	} {
		ast, err := Parse(s)
		require.Nil(t, err)
		require.Equal(t, 7, len(ast.TableOptions))
		require.NotNil(t, ast.TableOptions[0].IndexDirectory)
		require.Equal(t, "absolute path to directory", *ast.TableOptions[0].IndexDirectory)
		require.NotNil(t, ast.TableOptions[1].EngineAttribute)
		require.Equal(t, "foobar", *ast.TableOptions[1].EngineAttribute)
		require.NotNil(t, ast.TableOptions[2].InsertMethod)
		require.Equal(t, "NO", *ast.TableOptions[2].InsertMethod)
		require.NotNil(t, ast.TableOptions[3].KeyBlockSize)
		require.Equal(t, 23, *ast.TableOptions[3].KeyBlockSize)
		require.NotNil(t, ast.TableOptions[4].MaxRows)
		require.Equal(t, 12, *ast.TableOptions[4].MaxRows)
		require.NotNil(t, ast.TableOptions[5].MinRows)
		require.Equal(t, 1, *ast.TableOptions[5].MinRows)
		require.NotNil(t, ast.TableOptions[6].PackKeys)
		require.Equal(t, "DEFAULT", *ast.TableOptions[6].PackKeys)
	}

	for _, s := range []string{
		`CREATE TABLE foobar (id INT) 
  PACK_KEYS = 23
  PASSWORD = 'string'
  ROW_FORMAT = COMPACT
  SECONDARY_ENGINE_ATTRIBUTE = 'string'
  STATS_AUTO_RECALC = 1
  STATS_PERSISTENT  = DEFAULT
  STATS_SAMPLE_PAGES = 23
`,
		`CREATE TABLE foobar (id INT) 
  PACK_KEYS 23
  PASSWORD 'string'
  ROW_FORMAT COMPACT
  SECONDARY_ENGINE_ATTRIBUTE 'string'
  STATS_AUTO_RECALC 1
  STATS_PERSISTENT  DEFAULT
  STATS_SAMPLE_PAGES 23
`,
	} {
		ast, err := Parse(s)
		require.Nil(t, err)
		require.Equal(t, 7, len(ast.TableOptions))
		require.NotNil(t, ast.TableOptions[0].PackKeys)
		require.Equal(t, "23", *ast.TableOptions[0].PackKeys)
		require.NotNil(t, ast.TableOptions[1].Password)
		require.Equal(t, "string", *ast.TableOptions[1].Password)
		require.NotNil(t, ast.TableOptions[2].RowFormat)
		require.Equal(t, "COMPACT", *ast.TableOptions[2].RowFormat)
		require.NotNil(t, ast.TableOptions[3].SecondaryEngineAttribute)
		require.Equal(t, "string", *ast.TableOptions[3].SecondaryEngineAttribute)
		require.NotNil(t, ast.TableOptions[4].StatsAutoRecalc)
		require.Equal(t, "1", *ast.TableOptions[4].StatsAutoRecalc)
		require.NotNil(t, ast.TableOptions[5].StatsPersistent)
		require.Equal(t, "DEFAULT", *ast.TableOptions[5].StatsPersistent)
		require.NotNil(t, ast.TableOptions[6].StatsSamplePages)
		require.Equal(t, 23, *ast.TableOptions[6].StatsSamplePages)
	}

	for _, s := range []string{
		`CREATE TABLE foobar (id INT) 
  TABLESPACE table1 STORAGE DISK
  TABLESPACE table2
  TABLESPACE table3 STORAGE MEMORY
  UNION = (table1, table2, table3)
`,
		`CREATE TABLE foobar (id INT) 
  TABLESPACE table1 STORAGE DISK
  TABLESPACE table2
  TABLESPACE table3 STORAGE MEMORY
  UNION (table1, table2, table3)
`,
	} {
		ast, err := Parse(s)
		require.Nil(t, err)
		require.Equal(t, 4, len(ast.TableOptions))
		require.NotNil(t, ast.TableOptions[0].TableSpace)
		require.Equal(t, "table1", ast.TableOptions[0].TableSpace.Name)
		require.True(t, ast.TableOptions[0].TableSpace.IsDiskStorage)
		require.False(t, ast.TableOptions[0].TableSpace.IsMemoryStorage)

		require.NotNil(t, ast.TableOptions[1].TableSpace)
		require.Equal(t, "table2", ast.TableOptions[1].TableSpace.Name)
		require.False(t, ast.TableOptions[1].TableSpace.IsDiskStorage)
		require.False(t, ast.TableOptions[1].TableSpace.IsMemoryStorage)

		require.NotNil(t, ast.TableOptions[2].TableSpace)
		require.Equal(t, "table3", ast.TableOptions[2].TableSpace.Name)
		require.False(t, ast.TableOptions[2].TableSpace.IsDiskStorage)
		require.True(t, ast.TableOptions[2].TableSpace.IsMemoryStorage)

		require.Equal(t, 3, len(ast.TableOptions[3].Union))
		require.Equal(t, []string{"table1", "table2", "table3"}, ast.TableOptions[3].Union)
	}
}
